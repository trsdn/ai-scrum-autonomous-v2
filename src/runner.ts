import * as fs from "node:fs";
import { AcpClient } from "./acp/client.js";
import { resolveSessionConfig } from "./acp/session-config.js";
import { runRefinement } from "./ceremonies/refinement.js";
import { runSprintPlanning } from "./ceremonies/planning.js";
import { runParallelExecution } from "./ceremonies/parallel-dispatcher.js";
import { runSprintReview } from "./ceremonies/review.js";
import { runSprintRetro } from "./ceremonies/retro.js";
import { createSprintLog } from "./documentation/sprint-log.js";
import { appendVelocity } from "./documentation/velocity.js";
import { calculateSprintMetrics } from "./metrics.js";
import { holisticDriftCheck } from "./enforcement/drift-control.js";
import { escalateToStakeholder } from "./enforcement/escalation.js";
import { getIssue } from "./github/issues.js";
import type { IssueCreationState } from "./github/issue-rate-limiter.js";
import { closeMilestone, getNextOpenMilestone } from "./github/milestones.js";
import { logger as defaultLogger } from "./logger.js";
import {
  STATE_VERSION,
  saveState,
  loadState,
  getStatePath,
  acquireLock,
  releaseLock,
} from "./state-manager.js";
import { SprintEventBus } from "./events.js";
import { attachSprintNotifications } from "./notifications/sprint-notifications.js";
import type {
  SprintConfig,
  SprintPlan,
  SprintResult,
  ReviewResult,
  RetroResult,
  RefinedIssue,
} from "./types.js";

export type SprintPhase =
  | "init"
  | "refine"
  | "plan"
  | "execute"
  | "review"
  | "retro"
  | "complete"
  | "paused"
  | "failed";

export interface SprintState {
  version: string;
  sprintNumber: number;
  phase: SprintPhase;
  plan?: SprintPlan;
  result?: SprintResult;
  review?: ReviewResult;
  retro?: RetroResult;
  startedAt: Date;
  issuesCreatedCount?: number;
  error?: string;
}

// Re-export state persistence for consumers
export { saveState, loadState };

// --- Sprint Runner ---

export class SprintRunner {
  private state: SprintState;
  private client: AcpClient;
  private config: SprintConfig;
  private paused = false;
  private hitlMode = false;
  private phaseBeforePause: SprintPhase | null = null;
  private readonly log;
  readonly events: SprintEventBus;

  constructor(config: SprintConfig, eventBus?: SprintEventBus) {
    this.config = config;
    this.events = eventBus ?? new SprintEventBus();
    this.client = new AcpClient({
      timeoutMs: config.sessionTimeoutMs,
      permissions: {
        autoApprove: config.autoApproveTools,
        allowPatterns: config.allowToolPatterns,
      },
      onStreamChunk: (sessionId, text) => {
        this.events.emitTyped("worker:output", { sessionId, text });
      },
    });
    this.state = {
      version: STATE_VERSION,
      sprintNumber: config.sprintNumber,
      phase: "init",
      startedAt: new Date(),
      issuesCreatedCount: 0,
    };
    attachSprintNotifications(this.events, this.config.ntfy);
    this.log = defaultLogger.child({
      component: "sprint-runner",
      sprint: config.sprintNumber,
    });
  }

  /** Get the ACP client (for direct use by dashboard). */
  getClient(): AcpClient {
    return this.client;
  }

  /** Load saved state from disk (if any). Updates the runner's state for dashboard display. */
  loadSavedState(): SprintState | null {
    const previous = this.tryLoadPreviousState();
    if (previous) {
      this.state = { ...previous, issuesCreatedCount: previous.issuesCreatedCount ?? 0 };
      this.log.info({ phase: previous.phase }, "Loaded saved sprint state");
    }
    return previous;
  }

  /** Run the full sprint cycle, resuming from a previous crash if state exists. */
  async fullCycle(): Promise<SprintState> {
    acquireLock(this.config);
    try {
      // Check for previous state to resume from
      const previous = this.tryLoadPreviousState();
      const resuming = previous && previous.phase !== "complete" && previous.plan;

      if (resuming && previous.plan) {
        this.state = { ...previous, error: undefined, issuesCreatedCount: previous.issuesCreatedCount ?? 0 };
        this.log.info({ resumeFrom: previous.phase }, "Resuming sprint from previous state");
        this.events.emitTyped("sprint:start", { sprintNumber: this.config.sprintNumber, resumed: true });
        this.events.emitTyped("log", { level: "info", message: `Resuming Sprint ${this.config.sprintNumber} from ${previous.phase} phase` });
        await this.client.connect();

        // Determine where to resume based on previous phase
        const plan = previous.plan;
        let result = previous.result;
        let review = previous.review;

        // Filter out already-completed issues before execution
        await this.filterCompletedIssues(plan);

        // Warn about issues missing acceptance criteria
        this.warnMissingAcceptanceCriteria(plan);

        // If we crashed during or after execute but before review
        if (!result || previous.phase === "execute") {
          if (this.hitlMode) {
            this.log.info("HITL mode — pausing before execution for stakeholder review");
            this.events.emitTyped("log", { level: "info", message: "⏸ HITL: Pausing before execution — review the plan and resume in dashboard to continue" });
            this.pause();
          }
          await this.checkPaused();
          const workerModel = (await resolveSessionConfig(this.config, "worker")).model;
          this.transition("execute", workerModel, "Worker Agent");
          result = await this.runExecute(plan);
        }

        if (!review || previous.phase === "review") {
          await this.checkPaused();
          const reviewerModel = (await resolveSessionConfig(this.config, "reviewer")).model;
          this.transition("review", reviewerModel, "Review Agent");
          review = await this.runReview(result);
        }

        if (!previous.retro || previous.phase === "retro") {
          await this.checkPaused();
          this.transition("retro", undefined, "Retro Agent");
          const retro = await this.runRetro(result, review);
          this.state.retro = retro;
        }

        this.transition("complete");
        await this.client.disconnect();
        this.persistState();
        this.events.emitTyped("sprint:complete", { sprintNumber: this.config.sprintNumber });
        return this.state;
      }

      // --- Fresh sprint ---

      // 1. init
      this.transition("init");
      this.events.emitTyped("sprint:start", { sprintNumber: this.config.sprintNumber });
      createSprintLog(this.config.sprintNumber, `${this.config.sprintPrefix} cycle started`, 0, undefined, this.config.sprintPrefix, this.config.sprintSlug);
      await this.client.connect();

      // 2. refine
      await this.checkPaused();
      this.transition("refine", undefined, "Refinement Agent");
      const refined = await this.runRefine();

      // 3. plan
      await this.checkPaused();
      const plannerModel = (await resolveSessionConfig(this.config, "planner")).model;
      this.transition("plan", plannerModel, "Planning Agent");
      const plan = await this.runPlan(refined);

      // Broadcast planned issues so dashboard can update
      this.events.emitTyped("sprint:planned", {
        issues: plan.sprint_issues.map((i) => ({ number: i.number, title: i.title })),
      });

      // Filter out already-completed issues before execution
      await this.filterCompletedIssues(plan);

      // Warn about issues missing acceptance criteria
      this.warnMissingAcceptanceCriteria(plan);

      // 4. execute
      if (this.hitlMode) {
        this.log.info("HITL mode — pausing before execution for stakeholder review");
        this.events.emitTyped("log", { level: "info", message: "⏸ HITL: Pausing before execution — review the plan and resume in dashboard to continue" });
        this.pause();
      }
      await this.checkPaused();
      const workerModel = (await resolveSessionConfig(this.config, "worker")).model;
      this.transition("execute", workerModel, "Worker Agent");
      const result = await this.runExecute(plan);

      // 5. review
      await this.checkPaused();
      const reviewerModel = (await resolveSessionConfig(this.config, "reviewer")).model;
      this.transition("review", reviewerModel, "Review Agent");
      const review = await this.runReview(result);

      // 6. retro
      await this.checkPaused();
      this.transition("retro", undefined, "Retro Agent");
      const retro = await this.runRetro(result, review);

      // 7. complete
      this.state.retro = retro;
      this.transition("complete");
      await this.client.disconnect();
      this.persistState();
      this.events.emitTyped("sprint:complete", { sprintNumber: this.config.sprintNumber });

      return this.state;
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : String(err);
      this.state.phase = "failed";
      this.state.error = message;
      this.log.error({ error: message }, "Sprint cycle failed");
      this.events.emitTyped("sprint:error", { error: message });

      try {
        await this.client.disconnect();
      } catch {
        // best-effort disconnect
      }

      this.persistState();
      return this.state;
    } finally {
      releaseLock(this.config);
    }
  }

  /**
   * Run sprints in a continuous loop, auto-detecting the next sprint
   * from GitHub milestones. Closes each milestone on completion and
   * moves to the next open one. Stops when no open milestone is found.
   */
  static async sprintLoop(
    configBuilder: (sprintNumber: number) => SprintConfig,
    eventBus?: SprintEventBus,
  ): Promise<SprintState[]> {
    const log = defaultLogger.child({ component: "sprint-loop" });
    const results: SprintState[] = [];
    const bus = eventBus ?? new SprintEventBus();

    while (true) {
      // Use configBuilder to get prefix for milestone detection
      const sampleConfig = configBuilder(1);
      let next;
      try {
        next = await getNextOpenMilestone(sampleConfig.sprintPrefix);
      } catch (err: unknown) {
        const msg = err instanceof Error ? err.message : String(err);
        log.error({ error: msg }, "Failed to detect next sprint milestone — check that a milestone like 'Sprint N' exists");
        bus.emitTyped("log", { level: "error", message: `Milestone detection failed: ${msg}` });
        break;
      }
      if (!next) {
        log.info("No open sprint milestones found — loop complete");
        bus.emitTyped("log", { level: "info", message: "No open sprint milestones — loop complete" });
        break;
      }

      const { sprintNumber, milestone } = next;
      log.info({ sprintNumber, milestone: milestone.title }, "Starting sprint");
      bus.emitTyped("log", { level: "info", message: `Starting ${milestone.title}` });

      const config = configBuilder(sprintNumber);
      const runner = new SprintRunner(config, bus);
      const state = await runner.fullCycle();
      results.push(state);

      if (state.phase === "complete") {
        try {
          await closeMilestone(milestone.title);
          log.info({ milestone: milestone.title }, "Milestone closed");
        } catch (err: unknown) {
          log.warn({ err, milestone: milestone.title }, "Failed to close milestone");
        }
      } else {
        log.warn({ phase: state.phase }, "Sprint did not complete — stopping loop");
        bus.emitTyped("log", { level: "warn", message: `Sprint ${sprintNumber} failed — loop stopped` });
        break;
      }
    }

    return results;
  }
  /** Run the refinement phase */
  async runRefine(): Promise<RefinedIssue[]> {
    this.log.info("Running refinement");
    const refined = await runRefinement(this.client, this.config, this.events);
    this.log.info({ count: refined.length }, "Refinement complete");
    return refined;
  }

  /** Run the sprint planning phase */
  async runPlan(refinedIssues?: RefinedIssue[]): Promise<SprintPlan> {
    this.log.info("Running sprint planning");
    const plan = await runSprintPlanning(this.client, this.config, refinedIssues, this.events);
    this.state.plan = plan;
    this.persistState();
    this.log.info(
      { issues: plan.sprint_issues.length, points: plan.estimated_points },
      "Sprint planning complete",
    );
    return plan;
  }

  /** Run the execution phase */
  async runExecute(plan: SprintPlan): Promise<SprintResult> {
    this.log.info("Running parallel execution");

    const workerModel = (await resolveSessionConfig(this.config, "worker")).model;

    // Emit issue:start for all planned issues
    for (const issue of plan.sprint_issues) {
      this.events.emitTyped("issue:start", { issue, model: workerModel });
    }

    const result = await runParallelExecution(
      this.client,
      this.config,
      plan,
      this.events,
    );
    this.state.result = result;

    // Emit issue:done / issue:fail for each result
    for (const r of result.results) {
      if (r.status === "completed") {
        this.events.emitTyped("issue:done", {
          issueNumber: r.issueNumber,
          quality: r.qualityDetails,
          duration_ms: r.duration_ms,
        });
      } else {
        this.events.emitTyped("issue:fail", {
          issueNumber: r.issueNumber,
          reason: (r.qualityDetails?.checks ?? []).filter(c => !c.passed).map(c => c.name).join(", ") || "execution failed",
          duration_ms: r.duration_ms,
        });
      }
    }

    // Holistic drift check — update expectedFiles with actual changes per issue
    for (const r of result.results) {
      const issueInPlan = plan.sprint_issues.find((i) => i.number === r.issueNumber);
      if (issueInPlan && r.filesChanged.length > 0) {
        const existing = new Set(issueInPlan.expectedFiles);
        for (const f of r.filesChanged) existing.add(f);
        issueInPlan.expectedFiles = [...existing];
      }
    }
    const allChanged = result.results.flatMap((r) => r.filesChanged);
    const allExpected = plan.sprint_issues.flatMap((i) => i.expectedFiles);
    const driftReport = await holisticDriftCheck(allChanged, allExpected);

    if (driftReport.driftPercentage > 0) {
      this.log.warn(
        { driftPercentage: driftReport.driftPercentage },
        "Drift detected during execution",
      );
    }

    if (driftReport.unplannedChanges.length > this.config.maxDriftIncidents) {
      await escalateToStakeholder(
        {
          level: "must",
          reason: "Excessive drift detected",
          detail: `${driftReport.unplannedChanges.length} unplanned file changes exceed threshold of ${this.config.maxDriftIncidents}`,
          context: { driftReport },
          timestamp: new Date(),
        },
        {
          ntfyEnabled: false,
          maxIssuesCreatedPerSprint: this.config.maxIssuesCreatedPerSprint,
        },
        this.events,
        this.state as IssueCreationState,
      );
      this.pause();
    }

    this.persistState();
    this.log.info(
      {
        completed: result.results.filter((r) => r.status === "completed").length,
        failed: result.results.filter((r) => r.status === "failed").length,
      },
      "Execution complete",
    );
    return result;
  }

  /** Run the sprint review phase */
  async runReview(result: SprintResult): Promise<ReviewResult> {
    this.log.info("Running sprint review");
    const metrics = calculateSprintMetrics(result);
    const review = await runSprintReview(this.client, this.config, result, this.events);
    this.state.review = review;

    // Append velocity
    appendVelocity({
      sprint: this.config.sprintNumber,
      date: new Date().toISOString().slice(0, 10),
      goal: this.state.plan?.rationale ?? "",
      planned: metrics.planned,
      done: metrics.completed,
      carry: metrics.failed,
      hours: Math.round(metrics.avgDuration * metrics.planned / 3_600_000),
      issuesPerHr:
        metrics.avgDuration > 0
          ? Math.round((metrics.completed / (metrics.avgDuration * metrics.planned / 3_600_000)) * 100) / 100
          : 0,
      notes: review.summary,
    });

    this.persistState();
    this.log.info("Sprint review complete");
    return review;
  }

  /** Run the retrospective phase */
  async runRetro(result: SprintResult, review: ReviewResult): Promise<RetroResult> {
    this.log.info("Running sprint retro");
    const retro = await runSprintRetro(
      this.client,
      this.config,
      result,
      review,
      this.events,
      this.state as IssueCreationState,
    );
    this.state.retro = retro;
    this.persistState();
    this.log.info(
      { improvements: retro.improvements.length },
      "Sprint retro complete",
    );
    return retro;
  }

  /** Pause the sprint runner */
  pause(): void {
    if (this.state.phase !== "paused" && this.state.phase !== "failed" && this.state.phase !== "complete") {
      this.phaseBeforePause = this.state.phase;
      this.paused = true;
      this.state.phase = "paused";
      this.log.info({ previousPhase: this.phaseBeforePause }, "Sprint paused");
      this.events.emitTyped("sprint:paused", {});
      this.persistState();
    }
  }

  /** Resume the sprint runner */
  resume(): void {
    if (this.paused && this.phaseBeforePause) {
      this.paused = false;
      this.state.phase = this.phaseBeforePause;
      this.phaseBeforePause = null;
      this.log.info({ phase: this.state.phase }, "Sprint resumed");
      this.events.emitTyped("sprint:resumed", { phase: this.state.phase });
      this.persistState();
    }
  }

  /** Get current sprint state */
  getState(): SprintState {
    return { ...this.state };
  }

  /** Enable or disable HITL (Human-in-the-Loop) mode */
  setHitlMode(enabled: boolean): void {
    this.hitlMode = enabled;
    this.log.info({ hitlMode: enabled }, "HITL mode changed");
  }

  // --- Private helpers ---

  private transition(phase: SprintPhase, model?: string, agent?: string): void {
    const previous = this.state.phase;
    this.state.phase = phase;
    this.log.info({ from: previous, to: phase, model, agent }, "Phase transition");
    this.events.emitTyped("phase:change", { from: previous, to: phase, model, agent });
  }

  /** Filter out issues that already have the status:done label. */
  private async filterCompletedIssues(plan: SprintPlan): Promise<void> {
    if (!plan.sprint_issues?.length) return;
    const activeIssues = [];
    for (const issue of plan.sprint_issues) {
      try {
        const details = await getIssue(issue.number);
        const labels = details.labels?.map((l) => l.name) ?? [];
        if (labels.includes("status:done")) {
          this.log.warn({ issue: issue.number, title: issue.title }, "Skipping already-completed issue");
        } else {
          activeIssues.push(issue);
        }
      } catch (err: unknown) {
        // If we can't fetch the issue, keep it in the plan to be safe
        this.log.warn({ issue: issue.number, err }, "Could not check issue status, keeping in plan");
        activeIssues.push(issue);
      }
    }
    if (activeIssues.length < plan.sprint_issues.length) {
      this.log.info(
        { removed: plan.sprint_issues.length - activeIssues.length, remaining: activeIssues.length },
        "Filtered completed issues from sprint plan",
      );
      plan.sprint_issues = activeIssues;
    }
  }

  /** Warn about issues that have empty acceptance criteria. */
  private warnMissingAcceptanceCriteria(plan: SprintPlan): void {
    for (const issue of plan.sprint_issues) {
      if (!issue.acceptanceCriteria?.trim()) {
        this.log.warn(
          { issue: issue.number, title: issue.title },
          "Issue has no acceptance criteria — worker may produce low-quality output",
        );
        this.events.emitTyped("log", {
          level: "warn",
          message: `⚠️ Issue #${issue.number} has no acceptance criteria`,
        });
      }
    }
  }

  private async checkPaused(): Promise<void> {
    while (this.paused) {
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
  }

  private get stateFilePath(): string {
    return getStatePath(this.config);
  }

  private persistState(): void {
    try {
      saveState(this.state, this.stateFilePath);
    } catch (err: unknown) {
      this.log.warn({ err }, "Failed to persist sprint state");
    }
  }

  /** Try to load a previous state for this sprint. Returns null if none exists. */
  private tryLoadPreviousState(): SprintState | null {
    try {
      if (fs.existsSync(this.stateFilePath)) {
        return loadState(this.stateFilePath);
      }
    } catch (err: unknown) {
      this.log.warn({ err }, "Failed to load previous state — starting fresh");
    }
    return null;
  }
}
