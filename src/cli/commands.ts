/**
 * CLI command definitions ‚Äî all 13 commands registered on the Commander program.
 */

import type { Command } from "commander";
import { prefixToSlug } from "../config.js";
import { runSprintPlanning } from "../ceremonies/planning.js";
import { executeIssue } from "../ceremonies/execution.js";
import { runRefinement } from "../ceremonies/refinement.js";
import { runSprintReview } from "../ceremonies/review.js";
import { runSprintRetro } from "../ceremonies/retro.js";
import { runQualityGate, type QualityGateConfig } from "../enforcement/quality-gate.js";
import { getIssue, listIssues } from "../github/issues.js";
import { readSprintLog } from "../documentation/sprint-log.js";
import { holisticDriftCheck } from "../enforcement/drift-control.js";
import { getNextOpenMilestone } from "../github/milestones.js";
import { SprintRunner } from "../runner.js";
import { SprintEventBus } from "../events.js";
import { logger, redirectLogToFile } from "../logger.js";
import type { SprintIssue } from "../types.js";
import {
  buildSprintConfig,
  createConnectedClient,
  loadConfigFromOpts,
  parseSprintNumber,
  parseIssueNumber,
} from "./helpers.js";
import { initProject } from "./init.js";

/** Register all CLI commands on the given Commander program. */
export function registerCommands(program: Command): void {
  registerPlan(program);
  registerExecuteIssue(program);
  registerCheckQuality(program);
  registerRefine(program);
  registerFullCycle(program);
  registerWeb(program);
  registerReview(program);
  registerRetro(program);
  registerStatus(program);
  registerPause(program);
  registerResume(program);
  registerMetrics(program);
  registerDriftReport(program);
  registerInit(program);
}

// --- plan ---
function registerPlan(program: Command): void {
  program
    .command("plan")
    .description("Run sprint planning")
    .requiredOption("--sprint <number>", "Sprint number", parseSprintNumber)
    .option("--dry-run", "Plan without executing", false)
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);
        const sprintConfig = buildSprintConfig(config, opts.sprint);
        logger.info({ sprint: opts.sprint, dryRun: opts.dryRun }, "Starting sprint planning");

        const client = await createConnectedClient(config);
        try {
          const plan = await runSprintPlanning(client, sprintConfig);
          console.log("\n‚úÖ Sprint plan created:");
          console.log(`  Sprint: ${plan.sprintNumber}`);
          console.log(`  Issues: ${plan.sprint_issues.length}`);
          console.log(`  Estimated points: ${plan.estimated_points}`);
          console.log(`  Rationale: ${plan.rationale}`);
          for (const issue of plan.sprint_issues) {
            console.log(`    #${issue.number} ‚Äî ${issue.title} (${issue.points}pt, ICE=${issue.ice_score})`);
          }
        } finally {
          await client.disconnect();
        }
      } catch (err: unknown) {
        logger.error({ err }, "Sprint planning failed");
        console.error("‚ùå Sprint planning failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- execute-issue ---
function registerExecuteIssue(program: Command): void {
  program
    .command("execute-issue")
    .description("Execute a single issue")
    .requiredOption("--issue <number>", "Issue number", parseIssueNumber)
    .requiredOption("--sprint <number>", "Sprint number", parseSprintNumber)
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);
        const sprintConfig = buildSprintConfig(config, opts.sprint);
        logger.info({ issue: opts.issue, sprint: opts.sprint }, "Executing issue");

        // Fetch issue details from GitHub
        const ghIssue = await getIssue(opts.issue);
        const sprintIssue: SprintIssue = {
          number: ghIssue.number,
          title: ghIssue.title,
          ice_score: 0,
          depends_on: [],
          acceptanceCriteria: ghIssue.body ?? "",
          expectedFiles: [],
          points: 1,
        };

        const client = await createConnectedClient(config);
        try {
          const result = await executeIssue(client, sprintConfig, sprintIssue);
          console.log(`\n${result.status === "completed" ? "‚úÖ" : "‚ùå"} Issue #${result.issueNumber}: ${result.status}`);
          console.log(`  Quality gate: ${result.qualityGatePassed ? "passed" : "failed"}`);
          console.log(`  Branch: ${result.branch}`);
          console.log(`  Duration: ${(result.duration_ms / 1000).toFixed(1)}s`);
          console.log(`  Files changed: ${result.filesChanged.length}`);
          console.log(`  Retries: ${result.retryCount}`);
          if (!result.qualityGatePassed) {
            for (const check of result.qualityDetails.checks.filter((c) => !c.passed)) {
              console.log(`    ‚úó ${check.name}: ${check.detail}`);
            }
          }
        } finally {
          await client.disconnect();
        }
      } catch (err: unknown) {
        logger.error({ err }, "Issue execution failed");
        console.error("‚ùå Issue execution failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- check-quality ---
function registerCheckQuality(program: Command): void {
  program
    .command("check-quality")
    .description("Run quality gates on a branch")
    .requiredOption("--branch <name>", "Branch name")
    .option("--base <branch>", "Base branch for diff comparison")
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);
        const baseBranch = opts.base ?? config.project.base_branch;
        logger.info({ branch: opts.branch, baseBranch }, "Running quality gate");

        const gateConfig: QualityGateConfig = {
          requireTests: config.quality_gates.require_tests,
          requireLint: config.quality_gates.require_lint,
          requireTypes: config.quality_gates.require_types,
          requireBuild: config.quality_gates.require_build,
          maxDiffLines: config.quality_gates.max_diff_lines,
          testCommand: config.quality_gates.test_command,
          lintCommand: config.quality_gates.lint_command,
          typecheckCommand: config.quality_gates.typecheck_command,
          buildCommand: config.quality_gates.build_command,
        };

        const result = await runQualityGate(gateConfig, process.cwd(), opts.branch, baseBranch);
        console.log(`\n${result.passed ? "‚úÖ" : "‚ùå"} Quality gate: ${result.passed ? "PASSED" : "FAILED"}`);
        for (const check of result.checks) {
          console.log(`  ${check.passed ? "‚úì" : "‚úó"} ${check.name}: ${check.detail}`);
        }
        if (!result.passed) process.exit(1);
      } catch (err: unknown) {
        logger.error({ err }, "Quality gate check failed");
        console.error("‚ùå Quality gate check failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- refine ---
function registerRefine(program: Command): void {
  program
    .command("refine")
    .description("Run backlog refinement on type:idea issues")
    .requiredOption("--sprint <number>", "Sprint number", parseSprintNumber)
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);
        const sprintConfig = buildSprintConfig(config, opts.sprint);
        logger.info({ sprint: opts.sprint }, "Starting refinement");

        const client = await createConnectedClient(config);
        try {
          const refined = await runRefinement(client, sprintConfig);
          console.log(`\n‚úÖ Refinement complete: ${refined.length} issues refined`);
          for (const issue of refined) {
            console.log(`  #${issue.number} ‚Äî ${issue.title} (ICE=${issue.ice_score})`);
          }
        } finally {
          await client.disconnect();
        }
      } catch (err: unknown) {
        logger.error({ err }, "Refinement failed");
        console.error("‚ùå Refinement failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- full-cycle ---
function registerFullCycle(program: Command): void {
  program
    .command("full-cycle")
    .description("Run a full sprint cycle: refine ‚Üí plan ‚Üí execute ‚Üí review ‚Üí retro")
    .requiredOption("--sprint <number>", "Sprint number", parseSprintNumber)
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);
        const sprintConfig = buildSprintConfig(config, opts.sprint);
        logger.info({ sprint: opts.sprint }, "Starting full sprint cycle");

        const client = await createConnectedClient(config);
        try {
          // Step 1: Refine
          console.log("\nüîÑ Phase 1/5: Refinement...");
          const refined = await runRefinement(client, sprintConfig);
          console.log(`  Refined ${refined.length} issues`);

          // Step 2: Plan
          console.log("\nüîÑ Phase 2/5: Planning...");
          const plan = await runSprintPlanning(client, sprintConfig, refined);
          console.log(`  Planned ${plan.sprint_issues.length} issues (${plan.estimated_points} points)`);

          // Step 3: Execute all issues
          console.log("\nüîÑ Phase 3/5: Execution...");
          const results = [];
          for (const issue of plan.sprint_issues) {
            console.log(`  Executing #${issue.number} ‚Äî ${issue.title}...`);
            const result = await executeIssue(client, sprintConfig, issue);
            results.push(result);
            console.log(`    ${result.status === "completed" ? "‚úÖ" : "‚ùå"} ${result.status}`);
          }

          const sprintResult = {
            results,
            sprint: opts.sprint,
            parallelizationRatio: 1,
            avgWorktreeLifetime: results.reduce((s, r) => s + r.duration_ms, 0) / (results.length || 1),
            mergeConflicts: 0,
          };

          // Step 4: Review
          console.log("\nüîÑ Phase 4/5: Review...");
          const review = await runSprintReview(client, sprintConfig, sprintResult);
          console.log(`  ${review.demoItems.length} demo items, ${review.openItems.length} open items`);

          // Step 5: Retro
          console.log("\nüîÑ Phase 5/5: Retrospective...");
          const retro = await runSprintRetro(client, sprintConfig, sprintResult, review);
          console.log(`  ${retro.wentWell.length} went well, ${retro.wentBadly.length} went badly`);
          console.log(`  ${retro.improvements.length} improvements identified`);

          // Summary
          const completed = results.filter((r) => r.status === "completed").length;
          console.log(`\n‚úÖ Sprint ${opts.sprint} full cycle complete`);
          console.log(`  ${completed}/${results.length} issues completed`);
          console.log(`  ${review.summary}`);
        } finally {
          await client.disconnect();
        }
      } catch (err: unknown) {
        logger.error({ err }, "Full cycle failed");
        console.error("‚ùå Full cycle failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- web dashboard ---
function registerWeb(program: Command): void {
  program
    .command("web")
    .description("Launch web dashboard ‚Äî browser-based sprint monitor on localhost")
    .option("--sprint <number>", "Override sprint number (skip auto-detection)", parseSprintNumber)
    .option("--port <number>", "Dashboard server port (default: 9100)", (v) => parseInt(v, 10), 9100)
    .option("--run", "Start sprint execution immediately")
    .option("--once", "Run only one sprint instead of looping (implies --run)")
    .option("--log-file <path>", "Log file path (default: sprint-runner.log)", "sprint-runner.log")
    .option("--no-open", "Don't auto-open browser")
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);

        // Auto-detect sprint
        let initialSprint = opts.sprint as number | undefined;
        if (!initialSprint) {
          const next = await getNextOpenMilestone(config.sprint.prefix);
          if (!next) {
            console.error(`‚ùå No open sprint milestones found (prefix: "${config.sprint.prefix}").`);
            console.error(`   Create a milestone named '${config.sprint.prefix} N' in GitHub, or use --sprint <number>.`);
            process.exit(1);
          }
          initialSprint = next.sprintNumber;
        }

        redirectLogToFile(opts.logFile as string);
        logger.info({ sprint: initialSprint }, "Launching web dashboard");

        const eventBus = new SprintEventBus();
        const sprintConfig = buildSprintConfig(config, initialSprint);
        const runner = new SprintRunner(sprintConfig, eventBus);

        // Load saved state
        runner.loadSavedState();

        // Load initial issues
        let currentIssues: { number: number; title: string; status: "planned" | "in-progress" | "done" | "failed" }[] = [];
        try {
          const milestoneIssues = await listIssues({
            milestone: `${config.sprint.prefix} ${initialSprint}`,
            state: "open",
          });

          const savedState = runner.getState();
          const completedIssues = new Set<number>();
          const failedIssues = new Set<number>();
          if (savedState?.result) {
            for (const r of savedState.result.results) {
              if (r.status === "completed") completedIssues.add(r.issueNumber);
              else failedIssues.add(r.issueNumber);
            }
          }

          currentIssues = milestoneIssues.map((i) => ({
            number: i.number,
            title: i.title,
            status: completedIssues.has(i.number) ? "done" as const
              : failedIssues.has(i.number) ? "failed" as const
              : "planned" as const,
          }));
        } catch {
          // Non-critical
        }

        // Update issues from events
        eventBus.onTyped("sprint:planned", ({ issues: plannedIssues }) => {
          try {
            currentIssues = plannedIssues.map((i) => ({
              number: i.number,
              title: i.title,
              status: "planned" as const,
            }));
          } catch (err) { logger.warn({ err }, "event handler error: sprint:planned"); }
        });
        eventBus.onTyped("issue:start", ({ issue }) => {
          try {
            const existing = currentIssues.find((i) => i.number === issue.number);
            if (existing) {
              existing.status = "in-progress";
            } else {
              currentIssues.push({ number: issue.number, title: issue.title, status: "in-progress" });
            }
          } catch (err) { logger.warn({ err }, "event handler error: issue:start"); }
        });
        eventBus.onTyped("issue:done", ({ issueNumber }) => {
          try {
            const issue = currentIssues.find((i) => i.number === issueNumber);
            if (issue) issue.status = "done";
          } catch (err) { logger.warn({ err }, "event handler error: issue:done"); }
        });
        eventBus.onTyped("issue:fail", ({ issueNumber }) => {
          try {
            const issue = currentIssues.find((i) => i.number === issueNumber);
            if (issue) issue.status = "failed";
          } catch (err) { logger.warn({ err }, "event handler error: issue:fail"); }
        });

        // Start/loop functions
        const startLoop = () => {
          SprintRunner.sprintLoop(
            (sprintNumber) => buildSprintConfig(config, sprintNumber),
            eventBus,
          ).catch((err: unknown) => {
            const msg = err instanceof Error ? err.message : String(err);
            eventBus.emitTyped("sprint:error", { error: msg });
            eventBus.emitTyped("log", { level: "error", message: `Sprint loop crashed: ${msg}` });
          });
        };

        const startOnce = () => {
          runner.fullCycle().catch((err: unknown) => {
            const msg = err instanceof Error ? err.message : String(err);
            eventBus.emitTyped("sprint:error", { error: msg });
            eventBus.emitTyped("log", { level: "error", message: `Sprint crashed: ${msg}` });
          });
        };

        const onStart = opts.once ? startOnce : startLoop;

        // Sprint switching: reload issues for the new sprint
        const switchToSprint = async (sprintNumber: number) => {
          logger.info({ sprintNumber }, "switching dashboard to sprint");
          try {
            const milestoneIssues = await listIssues({
              milestone: `${config.sprint.prefix} ${sprintNumber}`,
              state: "open",
            });
            currentIssues = milestoneIssues.map((i) => ({
              number: i.number,
              title: i.title,
              status: "planned" as const,
            }));
          } catch {
            currentIssues = [];
          }
        };

        // Launch WebSocket server
        const { DashboardWebServer } = await import("../dashboard/ws-server.js");
        const dashboardServer = new DashboardWebServer({
          port: opts.port as number,
          host: "localhost",
          eventBus,
          getState: () => runner.getState(),
          getIssues: () => currentIssues,
          onStart,
          onPause: () => runner.pause(),
          onResume: () => runner.resume(),
          onStop: () => {
            runner.pause();
            eventBus.emitTyped("log", { level: "warn", message: "Sprint stopped by user" });
          },
          onSwitchSprint: switchToSprint,
          onModeChange: (mode) => {
            runner.setHitlMode(mode === "hitl");
            logger.info({ mode }, "execution mode changed");
          },
          projectPath: process.cwd(),
          activeSprintNumber: initialSprint,
          sprintPrefix: config.sprint.prefix,
          sprintSlug: prefixToSlug(config.sprint.prefix),
          maxIssuesPerSprint: config.sprint.max_issues,
        });

        await dashboardServer.start();
        const url = `http://localhost:${opts.port as number}`;
        console.log(`\n  üåê Dashboard running at ${url}\n`);

        // Auto-open browser
        if (opts.open !== false) {
          const { exec } = await import("node:child_process");
          const openCmd = process.platform === "darwin" ? "open" : process.platform === "win32" ? "start" : "xdg-open";
          exec(`${openCmd} ${url}`);
        }

        // Graceful shutdown
        const cleanup = async () => {
          await dashboardServer.stop();
          process.exit(0);
        };
        process.on("SIGINT", () => { cleanup(); });
        process.on("SIGTERM", () => { cleanup(); });

        // Catch unhandled errors
        process.on("unhandledRejection", (reason: unknown) => {
          const msg = reason instanceof Error ? reason.message : String(reason);
          eventBus.emitTyped("sprint:error", { error: msg });
          eventBus.emitTyped("log", { level: "error", message: `Unhandled error: ${msg}` });
        });

        // Auto-start if flags set
        if (opts.run || opts.once) {
          onStart();
        }
      } catch (err: unknown) {
        logger.error({ err }, "Web dashboard failed");
        console.error("‚ùå Web dashboard failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- review ---
function registerReview(program: Command): void {
  program
    .command("review")
    .description("Run sprint review ceremony")
    .requiredOption("--sprint <number>", "Sprint number", parseSprintNumber)
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);
        logger.info({ sprint: opts.sprint, project: config.project.name }, "Starting sprint review");

        // Attempt to load sprint log for context
        let logContent: string;
        try {
          logContent = readSprintLog(opts.sprint, undefined, prefixToSlug(config.sprint.prefix));
        } catch {
          console.error(`‚ùå No sprint log found for ${config.sprint.prefix} ${opts.sprint}.`);
          console.error("   Run the full-cycle or execute issues first to generate sprint data.");
          process.exit(1);
        }

        console.log(`üìã ${config.sprint.prefix} ${opts.sprint} log loaded (${logContent.length} chars)`);
        console.log("‚ö†Ô∏è  Sprint review requires a SprintResult from execution.");
        console.log("   Use 'full-cycle' for an end-to-end run, or provide sprint state.");
        console.log("   Sprint log preview:\n");
        console.log(logContent.slice(0, 500));
      } catch (err: unknown) {
        logger.error({ err }, "Sprint review failed");
        console.error("‚ùå Sprint review failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- retro ---
function registerRetro(program: Command): void {
  program
    .command("retro")
    .description("Run sprint retrospective ceremony")
    .requiredOption("--sprint <number>", "Sprint number", parseSprintNumber)
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);
        logger.info({ sprint: opts.sprint, project: config.project.name }, "Starting sprint retrospective");

        // Attempt to load sprint log for context
        let logContent: string;
        try {
          logContent = readSprintLog(opts.sprint, undefined, prefixToSlug(config.sprint.prefix));
        } catch {
          console.error(`‚ùå No sprint log found for ${config.sprint.prefix} ${opts.sprint}.`);
          console.error("   Run the full-cycle or execute issues first to generate sprint data.");
          process.exit(1);
        }

        console.log(`üìã ${config.sprint.prefix} ${opts.sprint} log loaded (${logContent.length} chars)`);
        console.log("‚ö†Ô∏è  Sprint retro requires SprintResult and ReviewResult from prior ceremonies.");
        console.log("   Use 'full-cycle' for an end-to-end run, or provide sprint state.");
        console.log("   Sprint log preview:\n");
        console.log(logContent.slice(0, 500));
      } catch (err: unknown) {
        logger.error({ err }, "Sprint retrospective failed");
        console.error("‚ùå Sprint retrospective failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- status ---
function registerStatus(program: Command): void {
  program
    .command("status")
    .description("Show status of running workers")
    .action(async () => {
      console.log("üìä Worker Status");
      console.log("  No active workers.");
      console.log("  (Worker status tracking is not yet implemented.)");
    });
}

// --- pause ---
function registerPause(program: Command): void {
  program
    .command("pause")
    .description("Pause running sprint execution")
    .action(async () => {
      console.log("‚è∏Ô∏è  Pause");
      console.log("  Sprint pause/resume is not yet implemented.");
      console.log("  To stop execution, terminate the process (Ctrl+C).");
    });
}

// --- resume ---
function registerResume(program: Command): void {
  program
    .command("resume")
    .description("Resume paused sprint execution")
    .action(async () => {
      console.log("‚ñ∂Ô∏è  Resume");
      console.log("  Sprint pause/resume is not yet implemented.");
      console.log("  Re-run the command to restart execution.");
    });
}

// --- metrics ---
function registerMetrics(program: Command): void {
  program
    .command("metrics")
    .description("Show sprint metrics from sprint log")
    .requiredOption("--sprint <number>", "Sprint number", parseSprintNumber)
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);
        logger.info({ sprint: opts.sprint, project: config.project.name }, "Loading sprint metrics");

        let logContent: string;
        try {
          logContent = readSprintLog(opts.sprint, undefined, prefixToSlug(config.sprint.prefix));
        } catch {
          console.error(`‚ùå No sprint log found for ${config.sprint.prefix} ${opts.sprint}.`);
          process.exit(1);
        }

        console.log(`üìà ${config.sprint.prefix} ${opts.sprint} Metrics`);
        console.log("‚îÄ".repeat(40));
        console.log(logContent);
      } catch (err: unknown) {
        logger.error({ err }, "Metrics retrieval failed");
        console.error("‚ùå Metrics retrieval failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- drift-report ---
function registerDriftReport(program: Command): void {
  program
    .command("drift-report")
    .description("Run drift analysis on current sprint changes")
    .requiredOption("--sprint <number>", "Sprint number", parseSprintNumber)
    .option("--changed-files <files...>", "List of changed files")
    .option("--expected-files <files...>", "List of expected files")
    .action(async (opts) => {
      try {
        const config = loadConfigFromOpts(program.opts().config);
        logger.info({ sprint: opts.sprint, project: config.project.name }, "Running drift report");

        const changedFiles: string[] = opts.changedFiles ?? [];
        const expectedFiles: string[] = opts.expectedFiles ?? [];

        if (changedFiles.length === 0) {
          console.log("‚ö†Ô∏è  No changed files provided. Use --changed-files to specify files.");
          console.log("   Example: sprint-runner drift-report --sprint 1 --changed-files src/a.ts src/b.ts --expected-files src/a.ts");
          process.exit(0);
        }

        const report = await holisticDriftCheck(changedFiles, expectedFiles);
        console.log(`\nüìä Drift Report ‚Äî Sprint ${opts.sprint}`);
        console.log("‚îÄ".repeat(40));
        console.log(`  Total files changed: ${report.totalFilesChanged}`);
        console.log(`  Planned changes:     ${report.plannedChanges}`);
        console.log(`  Drift percentage:    ${report.driftPercentage.toFixed(1)}%`);
        if (report.unplannedChanges.length > 0) {
          console.log("  Unplanned changes:");
          for (const file of report.unplannedChanges) {
            console.log(`    ‚ö†Ô∏è  ${file}`);
          }
          process.exit(1);
        } else {
          console.log("  ‚úÖ No unplanned changes detected.");
        }
      } catch (err: unknown) {
        logger.error({ err }, "Drift report failed");
        console.error("‚ùå Drift report failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}

// --- init ---
function registerInit(program: Command): void {
  program
    .command("init")
    .description("Initialize a project with .aiscrum/ roles and config")
    .option("--path <dir>", "Target project directory", process.cwd())
    .option("--force", "Overwrite existing files", false)
    .action(async (opts) => {
      try {
        console.log("üöÄ Initializing AI Scrum Sprint Runner...\n");

        const result = initProject({
          targetPath: opts.path,
          force: opts.force,
        });

        if (result.created.length > 0) {
          console.log("  ‚úÖ Created:");
          for (const f of result.created) {
            console.log(`     ${f}`);
          }
        }

        if (result.skipped.length > 0) {
          console.log("\n  ‚è≠Ô∏è  Skipped (already exist):");
          for (const f of result.skipped) {
            console.log(`     ${f}`);
          }
        }

        console.log(`\n‚úÖ Initialized! ${result.created.length} files created, ${result.skipped.length} skipped.`);

        if (result.configPath) {
          console.log(`\nüìù Edit ${result.configPath} to configure your project.`);
        }
      } catch (err: unknown) {
        logger.error({ err }, "Init failed");
        console.error("‚ùå Init failed:", err instanceof Error ? err.message : err);
        process.exit(1);
      }
    });
}
